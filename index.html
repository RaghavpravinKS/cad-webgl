<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CAD WebGL Viewer</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Space+Mono:ital,wght@0,400;0,700;1,400&display=swap"
        rel="stylesheet">

    <!-- Icons -->
    <script src="https://unpkg.com/@phosphor-icons/web"></script>

    <style>
        :root {
            --primary: #ff006e;
            --secondary: #8338ec;
            --bg-dark: #0a0a0a;
            --glass-bg: rgba(20, 20, 20, 0.6);
            --glass-border: rgba(255, 255, 255, 0.1);
            --text-main: #ffffff;
            --text-muted: rgba(255, 255, 255, 0.6);
        }

        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #050505 0%, #1a1a1a 100%);
            font-family: 'Inter', sans-serif;
            color: var(--text-main);
            -webkit-font-smoothing: antialiased;
        }

        /* Canvas */
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* UI Panels Common Styles */
        .ui-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            padding: 20px;
            transition: all 0.3s ease;
        }

        .ui-panel:hover {
            border-color: rgba(255, 0, 110, 0.3);
            box-shadow: 0 8px 40px rgba(255, 0, 110, 0.15);
        }

        /* Header / Title */
        h1 {
            margin: 0 0 16px 0;
            font-size: 1.1rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--text-main);
        }

        h1 i {
            color: var(--primary);
            font-size: 1.4rem;
        }

        /* Top Left: System Stats */
        #ui-layer {
            position: absolute;
            top: 24px;
            left: 24px;
            z-index: 10;
            width: 300px;
        }

        .stat-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
        }

        .stat-label {
            color: var(--text-muted);
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-label i {
            color: var(--primary);
            opacity: 0.8;
        }

        .stat-value {
            font-family: 'Space Mono', monospace;
            font-weight: 400;
            color: var(--text-main);
            background: rgba(255, 255, 255, 0.05);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #ff4444;
            display: inline-block;
            margin-right: 6px;
        }

        .status-active {
            background-color: var(--primary);
            box-shadow: 0 0 10px var(--primary);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
                box-shadow: 0 0 0 0 rgba(255, 0, 110, 0.4);
            }

            70% {
                opacity: 1;
                box-shadow: 0 0 0 6px rgba(255, 0, 110, 0);
            }

            100% {
                opacity: 1;
                box-shadow: 0 0 0 0 rgba(255, 0, 110, 0);
            }
        }

        /* Top Right: Controls Hint */
        #controls-hint {
            position: absolute;
            top: 24px;
            right: 24px;
            z-index: 10;
            width: 200px;
        }

        .control-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .control-item i {
            color: var(--primary);
            font-size: 1.1rem;
            width: 20px;
            text-align: center;
        }

        .control-item strong {
            color: var(--text-main);
            font-weight: 600;
        }

        /* Bottom Center: Action Bar */
        #controls-layer {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            display: flex;
            gap: 16px;
            align-items: center;
            padding: 12px 20px;
            border-radius: 50px;
            /* Pill shape */
        }

        /* File Upload Button */
        .custom-file-upload {
            background: rgba(255, 0, 110, 0.1);
            border: 1px solid rgba(255, 0, 110, 0.4);
            color: var(--primary);
            padding: 10px 24px;
            border-radius: 30px;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .custom-file-upload:hover {
            background: var(--primary);
            color: white;
            box-shadow: 0 4px 20px rgba(255, 0, 110, 0.4);
            transform: translateY(-2px);
        }

        input[type="file"] {
            display: none;
        }

        /* Separator */
        .separator {
            width: 1px;
            height: 24px;
            background: rgba(255, 255, 255, 0.1);
        }

        /* Material Controls */
        .control-group {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .control-group label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
            font-weight: 600;
        }

        select {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-main);
            padding: 8px 16px;
            border-radius: 8px;
            font-family: 'Space Mono', monospace;
            font-size: 0.8rem;
            cursor: pointer;
            outline: none;
            transition: border-color 0.2s;
        }

        select:hover,
        select:focus {
            border-color: var(--primary);
        }

        input[type="color"] {
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 50%;
            background: none;
            cursor: pointer;
            padding: 0;
            transition: transform 0.2s;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch {
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
        }

        input[type="color"]:hover {
            transform: scale(1.1);
        }

        /* Bottom Left: Logs */
        #logs-console {
            position: absolute;
            bottom: 24px;
            left: 24px;
            width: 350px;
            max-height: 200px;
            z-index: 10;
            display: none;
            font-family: 'Space Mono', monospace;
            font-size: 0.75rem;
        }

        .logs-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 8px;
        }

        .logs-title {
            color: var(--primary);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .close-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 1.1rem;
            transition: color 0.2s;
        }

        .close-btn:hover {
            color: white;
        }

        #logs-content {
            max-height: 150px;
            overflow-y: auto;
            color: var(--text-muted);
            line-height: 1.6;
            scrollbar-width: none;
            /* Firefox */
        }

        #logs-content::-webkit-scrollbar {
            display: none;
        }

        /* Chrome/Safari */

        .log-entry {
            margin-bottom: 4px;
            border-left: 2px solid transparent;
            padding-left: 8px;
        }

        .log-info {
            border-left-color: var(--primary);
        }

        .log-warn {
            border-left-color: #ffaa00;
            color: #ffcc00;
        }

        .log-error {
            border-left-color: #ff4444;
            color: #ff6666;
        }

        /* Loading Overlay */
        #loading-overlay {
            position: absolute;
            inset: 0;
            background: rgba(5, 5, 5, 0.9);
            backdrop-filter: blur(10px);
            z-index: 100;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(255, 0, 110, 0.1);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s cubic-bezier(0.4, 0, 0.2, 1) infinite;
            margin-bottom: 24px;
        }

        #loading-text {
            font-family: 'Space Mono', monospace;
            font-size: 1rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: var(--primary);
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* File Name Display */
        #file-name {
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Space Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-muted);
            white-space: nowrap;
        }
    </style>
</head>

<body>
    <!-- Top Left: System Stats -->
    <div id="ui-layer" class="ui-panel">
        <h1><i class="ph-fill ph-cube-transparent"></i> CAD Viewer</h1>
        <div class="stat-group">
            <div class="stat-item">
                <span class="stat-label"><i class="ph ph-activity"></i> Status</span>
                <div style="display: flex; align-items: center;">
                    <span id="status-dot" class="status-indicator"></span>
                    <span id="status-text" class="stat-value" style="background:none; padding:0;">Init...</span>
                </div>
            </div>
            <div class="stat-item">
                <span class="stat-label"><i class="ph ph-cpu"></i> Renderer</span>
                <span id="gpu-renderer" class="stat-value" title="Full Renderer String">Detecting...</span>
            </div>
            <div class="stat-item">
                <span class="stat-label"><i class="ph ph-factory"></i> Vendor</span>
                <span id="gpu-vendor" class="stat-value">Detecting...</span>
            </div>
            <div class="stat-item">
                <span class="stat-label"><i class="ph ph-gauge"></i> FPS</span>
                <span id="fps-counter" class="stat-value">0</span>
            </div>
        </div>
    </div>

    <!-- Top Right: Controls Hint -->
    <div id="controls-hint" class="ui-panel">
        <div
            style="margin-bottom: 12px; font-weight: 600; color: var(--primary); text-transform: uppercase; letter-spacing: 1px; font-size: 0.8rem; display: flex; align-items: center; gap: 8px;">
            <i class="ph ph-game-controller"></i> Controls
        </div>
        <div class="control-list">
            <div class="control-item"><i class="ph ph-mouse-left-click"></i> <span><strong>Rotate</strong> (Drag)</span>
            </div>
            <div class="control-item"><i class="ph ph-mouse-right-click"></i> <span><strong>Pan</strong> (Drag)</span>
            </div>
            <div class="control-item"><i class="ph ph-mouse-middle-click"></i> <span><strong>Zoom</strong> (Drag)</span>
            </div>
            <div class="control-item"><i class="ph ph-mouse-scroll"></i> <span><strong>Zoom</strong> (Scroll)</span>
            </div>
        </div>
    </div>

    <!-- Bottom Center: Main Controls -->
    <div id="controls-layer" class="ui-panel">
        <label for="file-upload" class="custom-file-upload">
            <i class="ph ph-upload-simple"></i> Open STEP
        </label>
        <input id="file-upload" type="file" accept=".step,.stp" />

        <div class="separator"></div>

        <div class="control-group">
            <label><i class="ph ph-paint-bucket"></i> Material</label>
            <select id="material-type">
                <option value="normal">Normal (Rainbow)</option>
                <option value="standard">Standard PBR</option>
                <option value="phong">Phong (Shiny)</option>
                <option value="lambert">Lambert (Matte)</option>
                <option value="wireframe">Wireframe</option>
            </select>
        </div>

        <div class="control-group">
            <label><i class="ph ph-palette"></i> Color</label>
            <input type="color" id="model-color" value="#ff006e" />
        </div>

        <span id="file-name">No file loaded</span>
    </div>

    <!-- Bottom Left: Logs -->
    <div id="logs-console" class="ui-panel">
        <div class="logs-header">
            <span class="logs-title"><i class="ph ph-terminal-window"></i> System Logs</span>
            <button class="close-btn" onclick="document.getElementById('logs-console').style.display='none'"><i
                    class="ph ph-x"></i></button>
        </div>
        <div id="logs-content"></div>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay">
        <div class="spinner"></div>
        <div id="loading-text">Processing Geometry...</div>
    </div>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const logsConsole = document.getElementById('logs-console');
        const logsContent = document.getElementById('logs-content');

        function logToScreen(msg, type = 'info') {
            logsConsole.style.display = 'block';
            const div = document.createElement('div');
            div.className = `log-entry log-${type}`;

            // Format time nicely
            const time = new Date().toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
            div.textContent = `[${time}] ${msg}`;

            logsContent.appendChild(div);
            logsContent.scrollTop = logsContent.scrollHeight;
            console.log(msg);
        }

        window.onerror = function (msg, url, lineNo, columnNo, error) {
            logToScreen(`Error: ${msg}`, 'error');
            return false;
        };

        let occt = null;

        async function initOCCT() {
            if (occt) return occt;

            logToScreen("Initializing OCCT Kernel...");

            const script = document.createElement('script');
            script.src = "https://cdn.jsdelivr.net/npm/occt-import-js@0.0.16/dist/occt-import-js.js";
            document.body.appendChild(script);

            return new Promise((resolve, reject) => {
                script.onload = () => {
                    logToScreen("Kernel loaded. Booting WASM...");
                    occtimportjs({
                        locateFile: (name) => {
                            if (name.endsWith('.wasm')) {
                                return 'https://cdn.jsdelivr.net/npm/occt-import-js@0.0.16/dist/occt-import-js.wasm';
                            }
                            return name;
                        }
                    }).then((instance) => {
                        occt = instance;
                        logToScreen("OCCT Ready.");
                        resolve(occt);
                    }).catch((err) => {
                        logToScreen("Init Failed: " + err, 'error');
                        reject(err);
                    });
                };
                script.onerror = (err) => {
                    logToScreen("Network Error: Failed to load OCCT.", 'error');
                    reject(err);
                };
            });
        }

        // GPU detection using WEBGL_debug_renderer_info extension
        function getGPUInfo() {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl', { powerPreference: 'high-performance' }) ||
                canvas.getContext('experimental-webgl', { powerPreference: 'high-performance' });

            if (!gl) return { error: "WebGL Unsupported" };

            let vendor = gl.getParameter(gl.VENDOR);
            let renderer = gl.getParameter(gl.RENDERER);

            // Use WEBGL_debug_renderer_info extension to get unmasked GPU info
            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
            if (debugInfo) {
                const unmaskedVendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                const unmaskedRenderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);

                if (unmaskedVendor) vendor = unmaskedVendor;
                if (unmaskedRenderer) renderer = unmaskedRenderer;
            }

            // Extract clean GPU name
            let gpuName = renderer;

            // Pattern 1: New ANGLE format (Chrome)
            const angleNewMatch = renderer.match(/ANGLE \((?:NVIDIA|AMD|Intel)[^,]*,\s*([^(]+)/);
            if (angleNewMatch) {
                gpuName = angleNewMatch[1].trim();
            } else {
                // Pattern 2: Old ANGLE format
                const angleOldMatch = renderer.match(/ANGLE \(([^)]+)\)/);
                if (angleOldMatch) {
                    gpuName = angleOldMatch[1];
                    gpuName = gpuName.replace(/Direct3D\d+.*$/i, '').trim();
                    gpuName = gpuName.replace(/OpenGL.*$/i, '').trim();
                    gpuName = gpuName.replace(/vs_\d+_\d+.*$/i, '').trim();
                    gpuName = gpuName.replace(/ps_\d+_\d+.*$/i, '').trim();
                }
            }

            // Pattern 3: Firefox direct format
            if (!angleNewMatch && !angleOldMatch && renderer.includes('NVIDIA')) {
                gpuName = renderer.replace(/\s*\/.*$/, '').trim();
            }

            return {
                vendor,
                renderer: gpuName,
                fullRenderer: renderer
            };
        }

        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const rendererEl = document.getElementById('gpu-renderer');
        const vendorEl = document.getElementById('gpu-vendor');

        const gpuInfo = getGPUInfo();

        if (gpuInfo.error) {
            statusText.textContent = "Error";
            statusText.style.color = "#ff4444";
            rendererEl.textContent = "N/A";
        } else {
            statusDot.classList.add('status-active');
            statusText.textContent = "Active";
            statusText.style.color = "#ff006e";
            rendererEl.textContent = gpuInfo.renderer;
            rendererEl.title = `Full: ${gpuInfo.fullRenderer}`;
            vendorEl.textContent = gpuInfo.vendor;
        }

        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505); // Matching body gradient start

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 10000);
        camera.position.set(100, 100, 100);

        const renderer = new THREE.WebGLRenderer({
            antialias: true,
            powerPreference: 'high-performance',
            alpha: true // Allow CSS background to show through if needed
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.useLegacyLights = false;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        controls.mouseButtons = {
            LEFT: THREE.MOUSE.ROTATE,
            MIDDLE: THREE.MOUSE.DOLLY,
            RIGHT: THREE.MOUSE.PAN
        };

        controls.zoomSpeed = 1.2;
        controls.rotateSpeed = 1.0;
        controls.panSpeed = 0.8;

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 10, 10);
        scene.add(dirLight);

        const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight2.position.set(-10, -5, -10);
        scene.add(dirLight2);

        let gridHelper = new THREE.GridHelper(500, 50, 0x333333, 0x111111);
        scene.add(gridHelper);

        // Material controls
        const materialTypeSelect = document.getElementById('material-type');
        const modelColorPicker = document.getElementById('model-color');
        let currentModelGroup = null;

        function createMaterial(type, color) {
            const colorValue = new THREE.Color(color);

            switch (type) {
                case 'normal':
                    return new THREE.MeshNormalMaterial({ side: THREE.DoubleSide });
                case 'standard':
                    return new THREE.MeshStandardMaterial({ color: colorValue, side: THREE.DoubleSide, metalness: 0.3, roughness: 0.6 });
                case 'phong':
                    return new THREE.MeshPhongMaterial({ color: colorValue, side: THREE.DoubleSide, shininess: 80 });
                case 'lambert':
                    return new THREE.MeshLambertMaterial({ color: colorValue, side: THREE.DoubleSide });
                case 'wireframe':
                    return new THREE.MeshBasicMaterial({ color: colorValue, wireframe: true, side: THREE.DoubleSide });
                default:
                    return new THREE.MeshNormalMaterial({ side: THREE.DoubleSide });
            }
        }

        function updateMaterial() {
            if (!currentModelGroup) return;

            const materialType = materialTypeSelect.value;
            const color = modelColorPicker.value;
            const newMaterial = createMaterial(materialType, color);

            currentModelGroup.traverse((child) => {
                if (child.isMesh) {
                    child.material = newMaterial;
                }
            });
        }

        materialTypeSelect.addEventListener('change', updateMaterial);
        modelColorPicker.addEventListener('input', updateMaterial);

        const fileInput = document.getElementById('file-upload');
        const fileNameDisplay = document.getElementById('file-name');
        const loadingOverlay = document.getElementById('loading-overlay');

        fileInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;

            fileNameDisplay.textContent = file.name;
            loadingOverlay.style.display = 'flex';
            logToScreen(`Loading: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`);

            try {
                const occtInstance = await initOCCT();

                logToScreen("Reading buffer...");
                const buffer = await file.arrayBuffer();

                logToScreen("Parsing STEP structure...");
                const fileData = new Uint8Array(buffer);
                const result = occtInstance.ReadStepFile(fileData, null);

                if (!result) {
                    throw new Error("Parser returned null.");
                }
                if (!result.meshes || result.meshes.length === 0) {
                    throw new Error("No geometry found.");
                }

                logToScreen(`Success: ${result.meshes.length} mesh(es) extracted.`);

                // Remove old model
                const toRemove = [];
                scene.traverse((child) => {
                    if (child.isMesh && child !== gridHelper) toRemove.push(child);
                });
                toRemove.forEach(child => scene.remove(child));
                if (currentModelGroup) {
                    scene.remove(currentModelGroup);
                }

                const group = new THREE.Group();
                const materialType = materialTypeSelect.value;
                const color = modelColorPicker.value;
                const material = createMaterial(materialType, color);

                for (const meshData of result.meshes) {
                    const geometry = new THREE.BufferGeometry();

                    if (meshData.attributes.position && meshData.attributes.position.array) {
                        const posArray = new Float32Array(meshData.attributes.position.array);
                        geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
                    }

                    if (meshData.attributes.normal && meshData.attributes.normal.array) {
                        const normArray = new Float32Array(meshData.attributes.normal.array);
                        geometry.setAttribute('normal', new THREE.BufferAttribute(normArray, 3));
                    } else {
                        geometry.computeVertexNormals();
                    }

                    if (meshData.index && meshData.index.array) {
                        const idxArray = new Uint32Array(meshData.index.array);
                        geometry.setIndex(new THREE.BufferAttribute(idxArray, 1));
                    }

                    const mesh = new THREE.Mesh(geometry, material);
                    group.add(mesh);
                }

                const box = new THREE.Box3().setFromObject(group);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());

                logToScreen(`Dimensions: ${size.x.toFixed(1)} x ${size.y.toFixed(1)} x ${size.z.toFixed(1)}`);

                group.position.sub(center);

                const maxDim = Math.max(size.x, size.y, size.z);

                // Update grid size based on model
                scene.remove(gridHelper);
                const gridSize = Math.max(maxDim * 2, 100);
                const gridDivisions = Math.max(Math.floor(gridSize / 10), 10);
                gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0x333333, 0x111111);
                scene.add(gridHelper);

                if (maxDim === 0 || !isFinite(maxDim)) {
                    logToScreen("Warning: Zero size model.", 'warn');
                } else {
                    const fov = camera.fov * (Math.PI / 180);
                    let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
                    cameraZ *= 3.5;

                    cameraZ = Math.max(cameraZ, maxDim * 1.5);

                    camera.position.set(cameraZ, cameraZ, cameraZ);
                    camera.lookAt(0, 0, 0);
                    controls.target.set(0, 0, 0);
                    controls.update();
                }

                scene.add(group);
                currentModelGroup = group;
                logToScreen("Render complete.");

            } catch (err) {
                console.error(err);
                logToScreen("Error: " + err.message, 'error');
                alert("Failed: " + err.message);
            } finally {
                loadingOverlay.style.display = 'none';
            }
        });

        let frameCount = 0;
        let lastTime = performance.now();
        const fpsEl = document.getElementById('fps-counter');

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);

            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                fpsEl.textContent = frameCount;
                frameCount = 0;
                lastTime = currentTime;
            }
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>

</html>